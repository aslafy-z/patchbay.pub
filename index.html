<!doctype html>

<html>
  <head>
    <link rel="stylesheet" type="text/css" href="./apps/simple_chat/chat.css">
    <style>

      :root {
              --main-max-width: 720px;
      }

      main {
        max-width: var(--main-max-width);
        margin: 0 auto;
      }

    </style>
  </head>

  <body>

    <main>
      <h1>What is it?</h1>

      <p>
        A web service that provides an infinite set of virtual
        channels. Each channel is represented by a URL. Here's an example
        channel:
      </p>

      <pre><code>
        https://patchbay.pub/aa7cc811-d21c-42ef-92cc-a5566fa38344
      </code></pre>

      <p>
        Generally, a channel is created by randomly generating a string long
        enough that no one else will guess it. All channels are publicly
        accessible (see
        <a href='#security'>Security</a>).
        Each channel is accessed by HTTP GET and POST requests. Channels can
        operate in one or both of two modes. By default, a channel models a
        multi-producer, multi-consumer (MPMC) queue, where GET requests add a
        consumer, and POSTs add a producer. Consumers will block if there
        aren't any producers, and producers will block if there aren't any
        consumers. Anything in a POST body is transmitted over the channel as
        soon as there is a consumer. 
      </p>

      <p>
        Let's try out a trivial example. Note that you should make up your own
        channel, since other people are likely to use the one below. It doesn't
        have to be fancy. Just a random 6-digit number (like
        https://patchbay.pub/447219) is likely fine for testing.
      </p>

      <p>
        If you run this GET to create a consumer, it will block:
      </p>

      <pre><code>
        curl https://patchbay.pub/aa7cc811-d21c-42ef-92cc-a5566fa38344
      </code></pre>

      <p>
        Until you also run this POST in another terminal to create a producer:
      </p>

      <pre><code>
        curl https://patchbay.pub/aa7cc811-d21c-42ef-92cc-a5566fa38344 -d "Hi there"
      </code></pre>

      <p>
        You can also try reversing the order, and observe that the producer
        blocks until you run the consumer.
      </p>

      <p>
        If you set the <code>pubsub=true</code> query parameter, the request
        uses the channel in a different mode. GETs act similar to before, but
        POSTs become non-blocking, and will broadcast messages to ALL
        consumers, not just the first one. As the name suggest, this models
        the
        <a target='_blank' href='https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern'>PubSub pattern</a>.
      </p>

      <h1>Cute. How is this useful?</h1>

      <p>
        I originally wanted an easy way to get a desktop notification on my
        laptop when a long-running job on a server I was SSH'd into finished.
        After a bit of experimenting I realized a small amount of additional
        features would go a long way to making a more generally useful tool.
        This morphed into the following question:
      </p>

      <p>
        "What is the 20% of
        <a target='_blank' href='https://ifttt.com/'>IFTTT</a>
        functionality I could implement to have 80% of IFTTT features that I
        would personally use?"
      </p>

      <p>
        patchbay is what I ended up with.
      </p>

      <p>
        So, with that brief motivation, here are a few examples of things you
        can model with MPMC queues and pubsub messages over HTTP:
      </p>

      <h2>Desktop notifications</h2>

      <p>
        Here's how my original goal is implemented using patchbay.pub. First,
        on my remote server:
      </p>

      <pre><code>
        ./longjob.sh; curl -X POST https://patchbay.pub/aa7cc811-d21c-42ef-92cc-a5566fa38344?pubsub=true
      </code></pre>

      <p>
        And on my Linux laptop with
        <a target='_blank' href='https://wiki.archlinux.org/index.php/Desktop_notifications'>desktop notifications</a>
        support:
      </p>

      <pre><code>
        curl https://patchbay.pub/aa7cc811-d21c-42ef-92cc-a5566fa38344?pubsub=true; notify-send "Job done"
      </code></pre>

      <p>
        That's it. I'll get a popup on my screen when the job is done. If I
        want to get real fancy I can re-run the consumer in a loop. I keep the
        following script running in the background ready to receive
        notifications from whatever producers I want, printing out the HTTP
        body from the producer:
      </p>

      <pre><code>
        #!/bin/bash

        while true
        do
            # Run curl in a subshell and pass the results to notify-send
            notify-send $(curl https://patchbay.pub/aa7cc811-d21c-42ef-92cc-a5566fa38344?pubsub=true)

            # Avoid too many requests if server is down or rejecting
            if [ "$?" -ne "0" ]; then
                sleep 1
            fi
        done
      </code></pre>

      <h2>Text notifications</h2>

      <p>
        Let's extend the previous example a bit. What if I want to go to lunch,
        but still get notified when the job on my server is done? The server
        is already broadcasting a pubsub message, so I don't need to make any
        changes there. I just need to add a consumer that can notify me on the
        go. How about using
        <a target='_blank' href='https://www.twilio.com/'>Twilio</a>
        to send myself a text message? First I followed the instructions to get
        the Twilio CLI installed an logged in on my laptop, then it's just a
        matter of calling it with the body received by the pubsub consumer:
      </p>

      <pre><code>
        twilio api:core:messages:create --from "+15017122661" --to "+15558675310" --body $(curl https://patchbay.pub/aa7cc811-d21c-42ef-92cc-a5566fa38344?pubsub=true)
      </code></pre>

      <p>
        Now I'll get a desktop notification, <em>and</em> a text message when
        the job is done.
      </p>


      <h2>Webhooks handling</h2>

      Receiving a text notification is useful, but what if I want to
      <em>send</em> a text and have it trigger some other event? This is easily
      done by logging in to the Twilio website, and using the console to point
      the SMS webhook to 
      <code>https://patchbay.pub/aa7cc811-d21c-42ef-92cc-a5566fa38344?pubsub=true</code>.

      Any texts to my number will now trigger a pubsub event on the same
      channel as before. For some reason Twilio uses URL parameter encoding for
      its webhook bodies, but it would still be relatively easy to make a
      script to parse it and get useful data out of it, rather than just an
      opaque event.

      <h2>Poor man's IRC</h2>

      <p>
        How about an ad-hoc chat app? This chat includes everyone currently
        visiting this page. It doesn't require any fancy WebRTC or WebSockets;
        just HTTP. It's implemented using the
        <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events'>server-sent events API</a>.
        Instead of the events being generated on the server, they originate
        from peer producers and are broadcast to all consumers. If there's no
        one else around, try opening it in another tab and talking to yourself.
      </p>

      <a href="./apps/simple_chat/" target="_blank">Open chat in tab</a>
      <div class='chat-container'></div>

      <p>
        The code is quite simple, and most of it is just UI stuff. Here's
        the meat of it:
      </p>

      <h2>Custom job queue</h2>

      <h2>Website hosting</h2>

      Time to get funky. You may be wondering why MPMC queue is the default
      mode, since all the examples have used pubsub=true. Here's why.
      This entire web site is being hosted over patchbay.pub. How? Because
      static site hosting can be modeled as a MPMC queue, where each file you
      want to host is a producer in a loop, and web browsers create a consumer
      with each request to a resource. As an example, here's essentially how I'm
      hosting the index.html for this page (note that it uses the root channel, /):

      <pre><code>
        while true; do curl -X POST https://patchbay.pub --data-binary ./index.html; done
      </code></pre>

      <p>
        And chat.js:
      </p>

      <pre><code>
        while true; do curl -X POST https://patchbay.pub/apps/simple_chat/chat.js --data-binary ./apps.simple_chat/chat.js; done
      </code></pre>

      <p>
        Again, there's nothing special about channel ids. Any valid URL path
        will do. In this case the channel ids carry extra semantic information
        corresponding to a HTTP resource location, but as far as the server is
        concerned, apps/simple_chat/chat.js is just a bunch of characters
        forming an id.
      </p>

      <p>
        Astute observers will see a problem here: what's preventing any of you
        from sending POST requests to those channels and competing with my
        producers to publish your own content in place of this page? For these
        few endpoints, I added a bit of authentication to ensure I'm the only
        one who can publish to them. In general I don't expect people to need
        publicly facing sites on patchbay.pub. I think sites hosted on
        privately shared channels (a la poor man's
        <a target='_blank' href='https://ngrok.com/'>ngrok</a>) are much more likely.
        But feel free to reach out if you want a "vanity channel" for some
        reason.
      </p>

      <h2>File sharing</h2>

      No sketchy web service is complete without the ability to share
      files with your friends. Pubsub messages are restricted in size, because
      each message has to be copied into memory in order to be broadcast.
      producer/consumer streams are under no such limitation. If you post a
      10GB file and send your friend a link, it will be efficiently streamed
      from your machine, through the patchbay.pub server, to your friend's
      machine. Note that bandwidth is currently quite rate-limited on the free
      server, so I only recommend this for relatively small files. Otherwise
      you'll be waiting a while.


      <h1 name='security'>Security</h1>

      <p>
        patchbay is designed for simple ad-hoc tasks, with very low friction
        being a primary goal.  As such, it probably shouldn't be used for an
        highly sensitive tasks.  In general, the longer and more random your
        channel id is, the less likely anyone else can guess it or stumble upon
        it. Also note that due to 1) rate limiting and 2) the fact that
        requests block by default, brute forcing is not a viable attack
        strategy for channel ids of even moderate length.
      </p>

      <h1 name='privacy'>Privacy</h1>
      <p>
        We don't look at anyone's data as it goes through our servers, but
        you can also use end-to-end encyption if you don't trust us.
      </p>

      <h1>Caveats</h1>
    </main>

    <script type='module'>

      import ChatComponent from './apps/simple_chat/chat.js';

      (async () => {

        const historyLength = 200;
        //const channel = 'http://localhost:9001/pubchat';
        const channel = 'https://patchbay.pub/pubchat';

        const chatContainerEl = document.querySelector('.chat-container');
        const chatEl = ChatComponent(channel, historyLength);
        chatContainerEl.appendChild(chatEl);
      })();
    </script>
  </body>
</html>
