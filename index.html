<!doctype html>

<html>
  <head>
    <link rel="stylesheet" type="text/css" href="./apps/simple_chat/chat.css">
    <style>

      :root {
              --main-max-width: 720px;
      }

      main {
        max-width: var(--main-max-width);
        margin: 0 auto;
      }

    </style>
  </head>

  <body>

    <main>
      <h1>What is it?</h1>

      <p>
        A web service that provides an infinite set of virtual
        channels. Each channel is represented by a URL. Here's an example
        channel:
      </p>

      <pre><code>
        https://patchbay.pub/aa7cc811-d21c-42ef-92cc-a5566fa38344
      </code></pre>

      <p>
        Generally, a channel is created by randomly generating a string long
        enough that no one else will guess it. All channels are publicly
        accessible (see
        <a href='#security'>Security</a>).
        Each channel is accessed by HTTP GET and POST requests. Channels can
        operate in one or both of two modes. By default, a channel models a
        multi-producer, multi-consumer queue, where GET requests add a
        consumer, and POSTs add a producer. Consumers will block if there
        aren't any producers, and producers will block if there aren't any
        consumers. Anything in a POST body is transmitted over the channel as
        soon as there is a consumer. 
      </p>

      <p>
        Let's try out a trivial example. Note that you should make up your own
        channel, since other people are likely to use the one below. It doesn't
        have to be fancy. Just a random 4-digit number (like
        https://patchbay.pub/4472) is likely fine for testing.
      </p>

      <p>
        If you run this GET to create a consumer, it will block:
      </p>

      <pre><code>
        curl https://patchbay.pub/aa7cc811-d21c-42ef-92cc-a5566fa38344
      </code></pre>

      <p>
        Until you also run this POST in another terminal to create a producer:
      </p>

      <pre><code>
        curl https://patchbay.pub/aa7cc811-d21c-42ef-92cc-a5566fa38344 -d "Hi there"
      </code></pre>

      <p>
        You can also try reversing the order, and observe that the producer
        blocks until you run the consumer.
      </p>

      <p>
        If you set the <code>pubsub=true</code> query parameter, the request
        uses the channel in a different mode. GETs act similar to before, but
        POSTs become non-blocking, and will broadcast messages to ALL
        consumers, not just the first one. As the name suggest, this models
        the
        <a target='_blank' href='https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern'>PubSub pattern</a>.
      </p>

      <h1>Cute; how is this useful?</h1>

      <p>
        I originally created patchbay because I wanted an easy way to get a
        desktop notification on my laptop when a long-running job on a server I
        was SSH'd into finished. After a bit of experimenting I realized a
        small amount of additional features would go a long way to making a
        more generally useful tool. This morphed into the question:
      </p>

      <p>
        "What is the 20% of
        <a target='_blank' href='https://ifttt.com/'>IFTTT</a>
        functionality I would have to implement to have 80% of IFTTT features
        that I would personally use?"
      </p>

      <p>
        So, with that brief motivation, here are a few examples of things you
        can model with MPMC queues and pubsub messages over HTTP:
      </p>

      <h2>Desktop notifications</h2>

      <p>
        Here's how my original goal is implemented using patchbay.pub. First,
        on my remote server:
      </p>

      <pre><code>
        ./longjob.sh; curl -X POST https://patchbay.pub/aa7cc811-d21c-42ef-92cc-a5566fa38344?pubsub=true
      </code></pre>

      <p>
        And on my Linux laptop with
        <a target='_blank' href='https://wiki.archlinux.org/index.php/Desktop_notifications'>desktop notifications</a>
        support:
      </p>

      <pre><code>
        curl https://patchbay.pub/aa7cc811-d21c-42ef-92cc-a5566fa38344?pubsub=true; notify-send "Job done"
      </code></pre>

      <p>
        That's it. I'll get a popup on my screen when the job is done. If I
        want to get real fancy I can run the receiver in a loop. I keep the
        following script running in the background ready to receive
        notifications from whatever producers I want, printing out the HTTP
        body from the producer:
      </p>

      <pre><code>
        #!/bin/bash

        while true
        do
            # Run curl in a subshell and pass the results to notify-send
            notify-send $(curl https://patchbay.pub/aa7cc811-d21c-42ef-92cc-a5566fa38344?pubsub=true)

            # Avoid too many requests if server is down or rejecting
            if [ "$?" -ne "0" ]; then
                sleep 1
            fi
        done
      </code></pre>

      <h2>Text notifications</h2>

      <p>
        Let's extend the previous example a bit. What if I want to go to lunch,
        but still get notified when the job on my server is done? The server
        is already broadcasting a pubsub message, so I don't need to make any
        changes there. I just need to add a consumer that can notify me on the
        go. How about using
        <a target='_blank' href='https://www.twilio.com/'>Twilio</a>
        to send myself a text message? First I followed the instructions to get
        the Twilio CLI installed an logged in on my laptop, then it's just a
        matter of calling it with the body received by the pubsub consumer:
      </p>

      <pre><code>
        twilio api:core:messages:create --from "+15017122661" --to "+15558675310" --body $(curl https://patchbay.pub/aa7cc811-d21c-42ef-92cc-a5566fa38344?pubsub=true)
      </code></pre>

      <p>
        Now I'll get a desktop notification, <em>and</em> a text message when
        the job is done.
      </p>


      <h2>Webhooks handling</h2>

      Receiving a text notification is useful, but what if I want to
      <em>send</em> a text and have it trigger some other event? This is easily
      done by logging in to the Twilio website, and using the console to point
      the SMS webhook to 
      <code>https://patchbay.pub/aa7cc811-d21c-42ef-92cc-a5566fa38344?pubsub=true</code>.

      Any texts to my number will now trigger a pubsub event on the same
      channel as before. For some reason Twilio uses URL parameter encoding for
      its webhook bodies, but it would still be relatively easy to make a
      script to parse it and get useful data out of it, rather than just an
      opaque event.

      <h2>Custom job queue</h2>
      <h2>Website hosting</h2>


      <a href="./apps/simple_chat/" target="_blank">Open chat in tab</a>
      <div class='chat-container'></div>

      <h1 name='security'>Security</h1>
    </main>

    <script type='module'>

      import ChatComponent from './apps/simple_chat/chat.js';

      (async () => {

        const historyLength = 200;
        //const channel = 'http://localhost:9001/pubchat';
        const channel = 'https://patchbay.pub/pubchat';

        const chatContainerEl = document.querySelector('.chat-container');
        const chatEl = ChatComponent(channel, historyLength);
        chatContainerEl.appendChild(chatEl);
      })();
    </script>
  </body>
</html>
